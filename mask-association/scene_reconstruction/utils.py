import re
from collections import defaultdict
from pathlib import Path
from typing import Dict, List, Union, Tuple

import torch
import h5py
import numpy as np
from torchtyping import TensorType as TorchTensor
from tqdm import tqdm

from utils.camera_poses import qt_to_matrix4x4, QuaternionCoeffOrder, HomogeneousTransform


Keypoints = TorchTensor["npts", 2]
Matches   = Dict[str, TorchTensor["nmatches", 2]] # (image_name, matching keypoint index pairs)


"""
"""
name2root      = lambda name:     re.search(r'(.+)-\d+', name).group(1)
name2frame_num = lambda name: int(re.search(r'.+-(\d+)', name).group(1))


def read_poses(path: Union[Path, str]) -> HomogeneousTransform:
    """
    Read and return poses from file generated by hloc. 
    """
    poses = []
    with open(path, 'r') as f:
        for line in f.readlines():
            line = line.strip().split(' ')
            q = torch.tensor([float(x) for x in line[1:5]])
            t = torch.tensor([float(x) for x in line[5:8]])
            poses.append(qt_to_matrix4x4(q, t, order=QuaternionCoeffOrder.WXYZ))
    return torch.stack(poses)


def read_pairs(path: Union[Path, str], as_dict=False) -> Union[Dict[str, str],
                                                               List[Tuple[str, str]]]:
    """
    Read and return pairs in sorted order from file generated by hloc. 
    """
    pairs = []
    with open(path, 'r') as f:
        for line in f.readlines():
            line = line.strip().split(' ')
            pairs.append((line[0], line[1]))
    pairs = sorted(list(set([(a, b) if a < b else (b, a) for a, b in pairs]))) # remove duplicates
    if as_dict:
        pairsdict = defaultdict(list)
        for a, b in pairs:
            pairsdict[a].append(b)
        return pairsdict
    return pairs


def save_pairs(path: Union[Path, str], pairs: List[Tuple[str, str]]) -> None:
    """
    Save pairs in sorted order to file in hloc format.
    """
    pairs = sorted([(a, b) if a < b else (b, a) for a, b in pairs])
    with open(path, 'w') as f:
        for a, b in pairs:
            f.write(f'{a} {b}\n')


def read_keypoints(path: Union[Path, str], image_names: List[str], return_uncertainty=False) -> Keypoints:
    """
    Read keypoints (x, y) for `image_names` frames from local descriptors file and possibly their uncertainty.
    """
    keypoints   = {}
    uncertainty = {}
    with h5py.File(str(path), 'r', libver='latest') as hfile:
        for name in image_names:
            dst = hfile[name]['keypoints']
            keypoints  [name] = torch.from_numpy(dst.__array__())
            uncertainty[name] = dst.attrs.get('uncertainty')
    if return_uncertainty:
        return keypoints, uncertainty
    return keypoints


def read_matches(path: Union[Path, str], pairs: List[Tuple[str, str]], return_scores=False, return_reverse=False) -> Matches:
    """
    Load matches for all frames matches file.
    :param return_scores : whether to return match scores
    :param return_reverse: whether to add (name2, name1) given (name1, name2) in matches (default not added)
    """
    def names2pair(name1, name2, separator='/'):
            return separator.join((name1.replace('/', '-'), name2.replace('/', '-')))

    def reverse_matches(x):
        return np.flip(x, axis=-1).copy()

    def process_names(name1, name2):
        n1n2 = names2pair(name1, name2)
        n2n1 = names2pair(name2, name1)
        if n1n2 in hfile:
            return n1n2, False
        return n2n1, True

    def process_matches(matches: np.ndarray, scores: np.ndarray, reverse: bool):
        index = np.where(matches != -1)[0]
        matches = np.stack([index, matches[index]], axis=-1)
        if reverse:
            matches = reverse_matches(matches) # copy as torch doesn't support negative strides
        return matches, scores[index]

    matches = defaultdict(dict)
    scores  = defaultdict(dict)
    with h5py.File(str(path), 'r', libver='latest') as hfile:
        for name1, name2 in tqdm(pairs, desc='Reading matches'):
            pair, reverse = process_names(name1, name2)
            m, s  = process_matches(
                hfile[pair]['matches0']        .__array__(),
                hfile[pair]['matching_scores0'].__array__(), 
                reverse=reverse
            )
            matches[name1][name2] = torch.from_numpy(m).long()
            if return_reverse:
                matches[name2][name1] = torch.from_numpy(reverse_matches(m)).long()
            if return_scores:
                scores [name1][name2] = torch.from_numpy(s)

    if return_scores:
        return matches, scores
    return matches